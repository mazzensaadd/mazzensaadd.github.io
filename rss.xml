<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/css" href="rss.css" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
<title>Mazen's Blog</title>
<description>Mazen's RSS feed.</description>
<language>en-us</language>
<link>https://mazzensaadd.github.io/rss.xml</link>
<atom:link href="http://mazzensaadd.github.io/rss.xml" rel="self" type="application/rss+xml" />

<!-- LB -->

<item>
<title>Root Access with Chroot</title>
<guid>https://mazzensaadd.github.io/blog/root-access-with-chroot.html</guid>
<link>https://mazzensaadd.github.io/blog/root-access-with-chroot.html</link>
<pubDate>Sat, 05 Mar 2022 04:13:53 +0200</pubDate>
<description><![CDATA[
<p>One night, I was tinkering around with my laptop doing an Archlinux
install (pretty typical night, isn‚Äôt it?) and I was reading through the
Archwiki page of the <strong>chroot</strong> command. If you‚Äôve done an
Arch install, you know what‚Äôs <strong>chroot</strong>, but if you
didn‚Äôt, let me explain.</p>
<p><strong>chroot</strong> enables you to change the apparent root
directory for the current running process and their children. But what
the heck does this mean? I will tell you. Let‚Äôs consider a situation
where your <em>grub.cfg</em> file has been fucked up for some unknown
reason and you can‚Äôt boot into the system. You know that the system is
still there but you can‚Äôt boot into it because the bootloader is
missing. What would you do? Wouldn‚Äôt it be great if there was a way to
gain access to your OS without needing the bootloader at all? Then you
can fix it and get everything up and running again, right? This is what
<strong>chroot</strong> does. You boot your laptop using a bootable USB
stick, running Linux of course. Then, you mount the partition containing
the root directory of your OS. After that, you use the
<strong>chroot</strong> command to change root into the disk you just
mounted. Now, you have root privileges on this os without needing to
open it. From here, you can fix your laptop and get grub working
again.</p>
<p>My thought was: ‚ÄúWhat if, instead of using it to fix broken laptops,
I use it to break into laptops? Wouldn‚Äôt this work just fine?‚Äù. This was
it. I grabbed my USB and flashed Endeavour OS on it. I then shut down my
laptop and booted into the USB stick. I mounted the correct partition
and chrooted into it and voal√°, I now have root privileges on my machine
without even needing to enter a single password.</p>
<p>I felt so powerful at this moment. I thought I have breached the
<em>Linux Security Myth</em>. Now, I can open anyone‚Äôs laptop and gain
root privileges and, from there, I can do lots of things, add a user for
me for example, to use his laptop without him knowing. Or I can change
his password and mess around with him. I can now <em>hack</em> into any
Linux machine that I have physical access to, right? Wrong.</p>
<p>The only possible way to stop such an attack is to encrypt your hard
disk (or your SSD if you can afford one xD). Encrypting will prevent
anyone random person from mounting your hard and reading it, thus
blocking any <strong>chroot</strong> attempt keeping you and your laptop
secure.</p>
<p>So, Kids, encrypt your disks and mess with your friends if you want
hehe.</p>
]]></description>
</item>


<item>
<title>How to play Wordle the UNIX way</title>
<guid>https://mazzensaadd.github.io/blog/how-to-play-wordle-the-unix-way.html</guid>
<link>https://mazzensaadd.github.io/blog/how-to-play-wordle-the-unix-way.html</link>
<pubDate>Tue, 22 Feb 2022 01:23:55 +0200</pubDate>
<description><![CDATA[
<p>
Today, ladies and gentlemen, I will tell you my secret about how to win in <a href="https://www.nytimes.com/games/wordle/index.html">Wordle</a>.
</p>

<p>
Here's what you will need:
<ul>
    <li>grep</li>
    <li>basic understanding of regular expressions</li>
    <li>a text file containing every word in the english dictionary. I got mine <a href="http://www.gwicks.net/justwords.html">here</a>.</li>
</ul>
</p>

<h2>Background</h2>
<p>
Wordle is a new puzzle that is played all over the world nowadays. In the game, you're asked to guess a 5-letter word that you have no idea what would it be. You have 6 trials. Each trial, you guess a word and the game tells you what letters are in the right position, what letters are in the word but are in the wrong position and what letters aren't in the word at all. You should use your vocabulary to eliminate words until you find the correct one. Otherwise, you lose the game for that day.
</p>

<h2>What if I am lazy but willing to win?</h2>

<p>
If the title fits you, we're similar. Here's how I did it so that I can win every game. This is tested on 11 different Wordle levels and I won them all. I can assure you that I had no idea what does the words mean but I still won.
</p>

<p>
First thing I did is getting an plain text English dictionary. Now, I have every word. I only need every 5-letter word letter right? Let's use 
grep to get this done.
</p>
<pre>
    <code>
$ grep "^.....$" dic.txt
    </code>
</pre>

<p>
Noice, now we have every 5-letter word. Let's guess the first word. After watching 3Blue1Brown talk about using information theory to play Wordle, I decide to use his opening word, <b>crane</b>. My first guess had three wrong letters and two right ones but not in the right position.
It looked like this.
<pre>
‚¨úüü®‚¨úüü®‚¨ú
</pre>
I now know that the word contains 'r' and 'n' and doesn't contain 'c', 'a' or 'e'. Let's use this information. I filtered my words so that I get every word that contains 'r' and 'n' and doesn't contain any of [cae]. Here's the command that did so
<pre>
    <code>
$ grep "^.....$" english3.txt | grep r | grep n |grep -v "[cae]" | grep -v ".r..." | grep -v "...n."
    </code>
</pre>
Then, I used some common sense to choose a word to be my next guess. I guess this part can be optimized more but here's my convention: I
look at the first letter in every word and choose the most repeated one. In this case, it was 'b'. After that, I look for the second most repeated character. When I find it, I try to find a word that starts with the first most repeated letter and has the second letter in it. My choice was <b>Burin</b>. Of course, I have no idea what the hell does this means. The second guess looked like this:
<pre>
‚¨ú‚¨úüü®‚¨úüü©
</pre>
Now, this is some progress. I now know that the word ends with 'n'. So, let's filter again.
<pre>
    <code>
grep "^....n$" english3.txt | grep r | grep n |grep -v "[caebui]" | grep -v ".r..." | grep -v "...n." | grep -v "..r.."
    </code>
</pre>
At this point, I still have 4 trails left and my computer is telling me that the only <em>four</em> possible words are "doorn", "shorn", "sworn" and "thorn". Let's use some common sense again and try to do it efficiently. What is the best word to choose in this case? My choice was "shorn" because if the first letter is wrong, I will eliminate "sworn" and if the second letter was wrong, I will eliminate "thorn".
I typed "shorn" and hit enter and here it was:
<pre>
‚¨úüü©üü©üü©üü©
</pre>
Every letter is perfectly right, except the first one. So I write the only world left that matches these criteria, "thorn", and hit enter. And voal√°, I Won. Without knowing the meaning of any of the words mentioned except for "crane".
</p>

<p>
Here's the full thing from the Wordle website:
<pre>
Wordle 248 4/6

‚¨úüü®‚¨úüü®‚¨ú
‚¨ú‚¨úüü®‚¨úüü©
‚¨úüü©üü©üü©üü©
üü©üü©üü©üü©üü©
</pre>
</p>

<p>
And this was "How to play Wordle the UNIX way".
</p>
]]></description>
</item>


<item>
<title>Virm</title>
<guid>https://mazzensaadd.github.io/blog/virm.html</guid>
<link>https://mazzensaadd.github.io/blog/virm.html</link>
<pubDate>Sat, 19 Feb 2022 02:29:44 +0200</pubDate>
<description><![CDATA[
<p>
I am a CLI guy myself. Graphical user interfaces don't appeal to me that much. I always go for the terminal-based options instead of the GUI ones. For instance, I am now writing this blog post in vi while listening to Umm Kulthum through a cmus (a terminal-based music player as well).
The terminal-based options are just faster and more efficient for me. 
</p>

<p>
When it comes to navigating the system and manipulating files and directories, I find myself using console file managers like nnn and ranger. But lately, I started relying on pure shell commands, cd and ls for instance. The only thing I missed about tui file managers was the bulk-rename and bulk-remove features. I started looking for alternatives for such features and I found <a href="https://github.com/thameera/vimv">vimv</a>. It lets you bulk-rename files using vim which is great because what I usually do when it comes to renaming is renaming episodes into more convenient names and vim helps get this job done very efficiently using macros.
</p>

<p>
The only thing that was missing is the Bulk-remove feature. So, I created <a href="https://github.com/mazzensaadd/virm">Virm</a>. It lets me use some vim magic and delete multiple files as if they were lines in text files. For me, this is much easier than following specific application's conventions every time I want to do a task. I know how to use vim, so let's use it everywhere xD.
</p>
]]></description>
</item>


<item>
<title>Why 12-hour clock is stupid</title>
<guid>https://mazzensaadd.github.io/blog/why-12hour-clock-is-stupid.html</guid>
<link>https://mazzensaadd.github.io/blog/why-12hour-clock-is-stupid.html</link>
<pubDate>Thu, 20 Jan 2022 00:57:34 +0200</pubDate>
<description><![CDATA[
<p>
        One thing that I don't really understand about the world is how people can make it unnecessarily complicated. It seems like us human beings tend to make things harder for ourselves <em>cuz we can</em>. 
</p>
<p>
        Take the 12-hour clock system people use nowadays as an example. Why would any sufficiently working brain decide on dividing the 24 hours in the day into two 12s? By doing so, you are just adding more ambiguity to your lives. Now, people have to deal with A.M. and P.M. that they don't even know their meanings. Why would anyone assign a specific region of his brain to handle such stupid things? This is completely inefficient. Instead of doing this shit, just be a normal creature and divide your day into equal 24 parts and assign every one of them a number. Not only this will make it easier for kids and even adults to understand, but also it will solve the weird misunderstandings that arise from A.M. and P.M. conflicts.
</p>
<p>
        I myself have always had a problem with the clock system since I was a kid. It was hard to remember what is what when it comes to A.M. and P.M. and I have always thought that this is only adding a complicity layer on something that was supposed to be simple. I'd ask adults around me if A.M. meant night or day and, for some reason, I was never able to remember the difference after a while.
</p>
<p>
        The irony about the whole thing is that only a few portion people actually know what does A.M. and P.M. stand for. They both stand for the Latin words <em>"ante merƒ´diem"</em> and <em>"post merƒ´diem"</em> which I doubt that if I showed these words to anyone who uses the 12-hour format, he will be able to recognize it. 
</p>
<p>
        I am using the 24-hour everywhere. My laptop, my phone, my watch, even this website is using the 24-hour system as a clock system. It's easier for me and helps preserve my brain computing power to be used in something more significant.
</p>
<p>
        Please help the world become a better place and start using 24-hour clock. Peace out!
</p>
]]></description>
</item>


<item>
<title>init</title>
<guid>https://mazzensaadd.github.io/blog/init.html</guid>
<link>https://mazzensaadd.github.io/blog/init.html</link>
<pubDate>Wed, 19 Jan 2022 21:29:34 +0200</pubDate>
<description><![CDATA[
    <p>Hi Anon!<br>blog has been initialized...<br>Remember... all I'm offering is the truth. Nothing more. Welcome to the real world.</p>
]]></description>
</item>


</channel>
</rss>

